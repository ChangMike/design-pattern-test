策略模式
1、使用继承
类和类的耦合性太强，有新需求直接往父类里添加，牵一发而动全身，扩展性差。
2、使用继承和接口
不会再出现牵一发而动全身的问题，扩展性还可以；
具体的类来实现接口，在具体的类里有大量的相同代码，代码复用性差。
3、策略模式（使用了面向接口和组合）
允许对象能够通过组合和委托来拥有不同的行为或算法。
代码复用性最好；扩展性好（如果有新需求，往算法族里添加一个算法就可以）。
总结：策略模式避免了纯粹的面向继承编程（扩展性差）、面向接口编程（代码复用性差）的缺点。
概念：定义多个算法族（一个算法族一个接口和多个实现类），使用组合多态调用其算法，并添加setter方法可以随时改变使用的算法
---
观察者模式（使用了面向接口和组合）
1、观察者的构造方法传入一个发布者，用来把自己注册给这个发布者
2、发布者有新消息就可以通知观察者了
---
装饰者模式
1、使用继承保证装饰者和被装饰者是同一种类型，可以把装饰者当做被装饰者使用
2、使用组合，装饰者就可以调用被装饰者的方法，并在调用前后添加自己的一些功能；或者根本不调用被装饰者的方法
---
工厂模式（使用了面向接口和组合）
简单工厂模式：把创建对象实例的代码封装起来，传入参数，如1、2、3，返回不同的对象
抽象工厂模式：需要多个不同的工厂实现
工厂方法模式：让子类决定需要实例化的类
解决初始化造成的耦合，从复杂的依赖中解脱；把对象的创建和使用解耦；把容易变化的部分（创建对象）集中起来统一管理。
---
单例模式
1、构造方法私有化，别人无法创建；2、建立一个静态的创建对象的方法；3、返回创建的对象
---
命令模式
遥控器里有多个按钮，每个按钮被声明为命令接口类型；被赋值为某个具体的命令实现类（遥控器按钮和命令实现类一一对应）。
也可以说：遥控器组合了命令引用，命令实现类组合了具体的电器。
遥控器组合多个按钮，每个按钮的实现类调用不同的方法实现——>每个按钮封装了不同的方法实现——>方法调用封装
命令模式将请求封装成不同的对象，以便实现不同的动作；命令模式也提供撤消操作
遥控器的每个按钮是对不同请求的包装，每个按钮对应不同的命令实现类，各个命令实现类封装了不同的方法调用
1、封装请求2、封装方法调用
---
适配器模式
---
外观模式
一个类组合多个类的对象，并在它的一个方法或接口里按照顺序调用组合进来的多个对象的方法
---
模板方法模式
模板方法放在抽象类里，模板方法里都是一些方法调用；
这些在模板方法里被调用的方法有些自己实现，有些让子类实现。
---
迭代器模式
迭代器模式提供顺序访问一个集合中的元素，而又不暴露其内部的数据结构。
---
组合模式
组合迭代器（这个比较复杂）
可以将对象组成树形结构来表现整体/部分的层次结构，可以让我们以一致的方式处理个别对象和组合对象。
组合持有一群孩子，孩子可以是组合也可以叶子节点。
故意违反单一责任设计原则，有些方法只支持组合，有些方法只支持叶子节点。失去了一些安全性；换来了透明性，我们可以把组合和叶子节点一视同仁。
把一些对象组织成树形结构，忽略个别对象和组合对象的差别
---
状态模式
状态模式和策略模式是一对双胞胎。
状态模式定义了一个状态算法族，状态接口里定义了统一的方法，每个状态实现这些方法。在不同的状态有不同的行为。
符合开放/关闭原则，对扩展友好。