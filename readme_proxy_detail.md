#### 代理模式详解——Proxy-Pattern5
---
com.test.proxy1——硬编码，修改源码记录方法运行时间
假如我们不能修改源码，比如源码在一个第三方jar包里
---
静态代理
com.test.proxy2——使用继承记录方法运行时间
com.test.proxy3——使用接口和组合记录方法运行时间
使用接口和组合优于使用继承
---
com.test.proxy4——使用接口和组合扩展记录日志
   1. 需求改变，不只记录运行时间，还要记录日志   
增加一个记录日志的实现类即可
   2. 需求改变，先记录日志，再记录运行时间   
在测试的时候创建对象语句顺序调换一下即可
   3. 需求改变，还要添加事务   
增加一个添加事务的实现类即可
---
假如使用继承
   1. 需求改变，不只记录运行时间，还要记录日志   
写一个记录日志的类，继承记录时间的类
   2. 需求改变，先记录日志，再记录运行时间；以后可能还要把改为先记录运行时间，再记录日志   
再建一个记录日志的类，继承自原始类；再建一个记录运行时间的类，继承自日志类
---------------------------------------------------------------
使用接口和组合/使用继承的共同缺点   
假如Tank类里有好多方法，每个方法都需要记录运行时间，那么在继承或实现的类里都要重写每个方法   
假如现在的不只是记录Tank类方法的运行时间，还要记录Car类方法的运行时间，甚至还有Bike类、Animal类
---------------------------------------------------------------
com.test.proxy5——字符串类实现动态代理   
可以生成任意接口的代理实现类
   1. 把com.test.proxy3包里的TankTimeProxy.java类复制出一份来，把包名最后的3改为5
   2. 把复制出来的整个类加工成一个字符串并赋值给一个变量
   3. 继续修改字符串，声明一个接口类型的Class对象；修改字符串所实现的接口；修改字符串构造方法传入的参数（这样可以生成任意接口的动态代理类）
   4. 编译源码，这个源码就是代理类
   5. 加载代理类的字节码文件并实例化
---------------------------------------------------------------
com.test.proxy6——把代码写在自定义的newProxyInstance方法里   
可以生成任意接口的代理实现类
---------------------------------------------------------------
com.test.proxy7——从字符串里抽取methodStr   
接口里的所有方法都被添加记录运行时间的代码
---------------------------------------------------------------
com.test.proxy8——增加了InvocationHandler   
抽取记录运行时间的代码，可以添加任意想要添加的代码，比如日志、事务等等   
可以生成任意接口的代理实现类、接口内所有方法都被添加记录运行时间的代码、添加任意代码比如日志、事务等
---------------------------------------------------------------
com.test.proxy9——扩展事务
