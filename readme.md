#### 策略模式
- Strategy-Pattern1使用了继承
- Strategy-Pattern2使用接口封装可能变化的部分
- Strategy-Pattern3使用了最原始的策略模式
1. 使用继承为Duck提供行为   
类和类的耦合性太强，有新需求直接往父类里添加，牵一发而动全身，扩展性差。
   - 改变会牵一发而动全身，造成其它鸭子不想要的改变
   - 有重复代码，比如在多个具体类中都出现了这样的方法——覆盖父类定义，什么都不做
   - 很难知道所有鸭子的所有行为
   - 行为不容易改变
2. 使用继承和接口   
   - 已解决问题   
    1. 不会出现牵一发而动全身的问题，扩展性还可以   
    2. 把可能变化的部分抽取出来到接口，具体类需要什么功能自己实现相应接口，这样就不会造成原来在基类牵一发而动全身的情况
   - 新问题   
具体的类来实现接口，在具体的类里有大量的相同代码，代码复用性差。
    1. 重复代码很多，比如在红头鸭和绿头鸭的fly方法、quack方法都是重复的
    2. 在测试类里声明一个具体的鸭子的时候，不可以使用父类引用指向子类对象，因为有些方法定义在子类中（实现接口的部分方法）

3. 策略模式（使用了面向接口和组合）
允许对象能够通过组合和委托来拥有不同的行为或算法。   
代码复用性最好；扩展性好（如果有新需求，往算法族里添加一个算法就可以）。   
总结：策略模式避免了纯粹的面向继承编程（扩展性差）、面向接口编程（代码复用性差）的缺点。   
概念：定义多个算法族（一个算法族一个接口和多个实现类），使用组合多态调用其算法，并添加setter方法可以随时改变使用的算法   



