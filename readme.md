#### 策略模式
- Strategy-Pattern1使用了继承
- Strategy-Pattern2使用接口封装可能变化的部分
- Strategy-Pattern3使用了策略模式
1. 使用继承为Duck提供行为   
类和类的耦合性太强，有新需求直接往父类里添加，牵一发而动全身，扩展性差。
   - 改变会牵一发而动全身，造成其它鸭子不想要的改变
   - 有重复代码，比如在多个具体类中都出现了这样的方法——覆盖父类定义，什么都不做
   - 很难知道所有鸭子的所有行为
   - 行为不容易改变
2. 使用继承和接口   
   - 已解决问题   
    1. 不会出现牵一发而动全身的问题，扩展性还可以   
    2. 把可能变化的部分抽取出来到接口，具体类需要什么功能自己实现相应接口，这样就不会造成原来在基类牵一发而动全身的情况
   - 新问题   
    1. 重复代码很多，比如在红头鸭和绿头鸭的fly方法、quack方法都是重复的
    2. 在测试类里声明一个具体的鸭子的时候，不可以使用父类引用指向子类对象，因为有些方法定义在子类中（实现接口的部分方法）

3. 策略模式
   - 封装变化-->面向接口-->组合-->解耦-->开放关闭
   
      <details>
      <summary>详细</summary>

      把可能发生变化的部分封装成算法族-->算法族面向接口编程-->组合-->解耦-->开放关闭
      </details>
   
4. 举例   
Spring的Resource接口和ResourcesLoader接口   



